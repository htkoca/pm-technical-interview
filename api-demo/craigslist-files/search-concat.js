/*

 sSSSS  TTTTTTT  oOOOo  PPPPPp  !!!
SS        TTT   OO   OO PP   PP !!!
 SSSSs    TTT   OO   OO PPPPPP  !!!
     SS   TTT   OO   OO PP
 SSSSS    TTT    OOOOO  PP      !!!

 THIS IS NOT THE FILE YOU ARE LOOKING FOR. THIS FILE IS AUTOMATICALLY GENERATED. SEE concat.json FOR DETAILS.

*/
/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// 
// Topic: Note for non-jQuery users
// 
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
// 
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().

(function(window,undefined){
  '$:nomunge'; // Used by YUI compressor.

  // Since jQuery really isn't required for this plugin, use `jQuery` as the
  // namespace only if it already exists, otherwise use the `Cowboy` namespace,
  // creating it if necessary.
  var $ = window.jQuery || window.Cowboy || ( window.Cowboy = {} ),

    // Internal method reference.
    jq_throttle;

  // Method: jQuery.throttle
  // 
  // Throttle execution of a function. Especially useful for rate limiting
  // execution of handlers on events like resize and scroll. If you want to
  // rate-limit execution of a function to a single time, see the
  // <jQuery.debounce> method.
  // 
  // In this visualization, | is a throttled-function call and X is the actual
  // callback execution:
  // 
  // > Throttled with `no_trailing` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X    X        X    X    X    X    X    X
  // > 
  // > Throttled with `no_trailing` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X             X    X    X    X    X
  // 
  // Usage:
  // 
  // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
  // > 
  // > jQuery('selector').bind( 'someevent', throttled );
  // > jQuery('selector').unbind( 'someevent', throttled );
  // 
  // This also works in jQuery 1.4+:
  // 
  // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  // 
  // Arguments:
  // 
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
  //    true, callback will only execute every `delay` milliseconds while the
  //    throttled-function is being called. If no_trailing is false or
  //    unspecified, callback will be executed one final time after the last
  //    throttled-function call. (After the throttled-function has not been
  //    called for `delay` milliseconds, the internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the throttled-function is executed.
  // 
  // Returns:
  // 
  //  (Function) A new, throttled, function.

  $.throttle = jq_throttle = function( delay, no_trailing, callback, debounce_mode ) {
    // After wrapper has stopped being called, this timeout ensures that
    // `callback` is executed at the proper times in `throttle` and `end`
    // debounce modes.
    var timeout_id,

      // Keep track of the last time `callback` was executed.
      last_exec = 0;

    // `no_trailing` defaults to falsy.
    if ( typeof no_trailing !== 'boolean' ) {
      debounce_mode = callback;
      callback = no_trailing;
      no_trailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing
    // functionality and when executed will limit the rate at which `callback`
    // is executed.
    function wrapper() {
      var that = this,
        elapsed = +new Date() - last_exec,
        args = arguments;

      // Execute `callback` and update the `last_exec` timestamp.
      function exec() {
        last_exec = +new Date();
        callback.apply( that, args );
      };

      // If `debounce_mode` is true (at_begin) this is used to clear the flag
      // to allow future `callback` executions.
      function clear() {
        timeout_id = undefined;
      };

      if ( debounce_mode && !timeout_id ) {
        // Since `wrapper` is being called for the first time and
        // `debounce_mode` is true (at_begin), execute `callback`.
        exec();
      }

      // Clear any existing timeout.
      timeout_id && clearTimeout( timeout_id );

      if ( debounce_mode === undefined && elapsed > delay ) {
        // In throttle mode, if `delay` time has been exceeded, execute
        // `callback`.
        exec();

      } else if ( no_trailing !== true ) {
        // In trailing throttle mode, since `delay` time has not been
        // exceeded, schedule `callback` to execute `delay` ms after most
        // recent execution.
        // 
        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
        // after `delay` ms.
        // 
        // If `debounce_mode` is false (at end), schedule `callback` to
        // execute after `delay` ms.
        timeout_id = setTimeout( debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay );
      }
    };

    // Set the guid of `wrapper` function to the same of original callback, so
    // it can be removed in jQuery 1.4+ .unbind or .die by using the original
    // callback as a reference.
    if ( $.guid ) {
      wrapper.guid = callback.guid = callback.guid || $.guid++;
    }

    // Return the wrapper function.
    return wrapper;
  };

  // Method: jQuery.debounce
  // 
  // Debounce execution of a function. Debouncing, unlike throttling,
  // guarantees that a function is only executed a single time, either at the
  // very beginning of a series of calls, or at the very end. If you want to
  // simply rate-limit execution of a function, see the <jQuery.throttle>
  // method.
  // 
  // In this visualization, | is a debounced-function call and X is the actual
  // callback execution:
  // 
  // > Debounced with `at_begin` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // >                          X                                 X
  // > 
  // > Debounced with `at_begin` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X                                 X
  // 
  // Usage:
  // 
  // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
  // > 
  // > jQuery('selector').bind( 'someevent', debounced );
  // > jQuery('selector').unbind( 'someevent', debounced );
  // 
  // This also works in jQuery 1.4+:
  // 
  // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  // 
  // Arguments:
  // 
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
  //    unspecified, callback will only be executed `delay` milliseconds after
  //    the last debounced-function call. If at_begin is true, callback will be
  //    executed only at the first debounced-function call. (After the
  //    throttled-function has not been called for `delay` milliseconds, the
  //    internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the debounced-function is executed.
  // 
  // Returns:
  // 
  //  (Function) A new, debounced, function.

  $.debounce = function( delay, at_begin, callback ) {
    return callback === undefined
      ? jq_throttle( delay, at_begin, false )
      : jq_throttle( delay, callback, at_begin !== false );
  };

})(this);
;
$.widget( "custom.dropdown", {
    options: {
        onSelect : function () {
            // callback for click events
        }
    },
    _create: function() {
        this._setDropdownToCurrentSelection();

        this._on(this.element, {
            click : function(e) {
                var $self = $(this.element);
                var $thisList = $self.children('.dropdown-list');

                if ($thisList.hasClass('dropdown-show')) {
                    this._closeDropdown();
                    this._unfocus();
                    this.options.onSelect(e); // trigger custom callback
                    this._setDropdownToCurrentSelection();
                } else {
                    e.preventDefault();

                    this._openDropdown();
                }
            },

            // keyboard navigation handling for accessibility
            keydown : function(e) {
                var activateKeys = [9, 13, 32, 38, 40]; // these keys can show the menu

                var $target = $(e.target);
                var $dropdown = $(this.element);
                var $dropdownList = $dropdown.find('.dropdown-list');
                var isDropdownElt = $dropdown.length > 0;
                var key = Number(e.which);

                // if escape, close menu
                if (key === 27) {
                    this._closeDropdown();
                    return;
                }

                // if enter, let my selections submit
                if (key === 13) {
                    this.options.onSelect(e); // trigger custom callback
                    return;
                }

                if (isDropdownElt) {
                    var isMenuVisible = $dropdownList.hasClass('dropdown-show');

                    if (!isMenuVisible && (activateKeys.indexOf(key) >= 0)) {
                        e.preventDefault();
                        this._openDropdown();
                    } else {
                        e.preventDefault();
                        this._navigateMenu(e, key, $target);
                    }
                }
            }
        });

        this._on( this.element, {
            updateView : function (e) {
                this._setDropdownToCurrentSelection();
            }
        });

        // close the menu if the user clicks elsewhere on the page
        this._on( this.document, {
            click : function (e) {
                var isDropdownShowing = $(this.element).find('.dropdown-list').hasClass('dropdown-show');
                if (isDropdownShowing && this._shouldCloseOnDocumentClick(e)) {
                    this._unfocus();
                    this._closeDropdown();
                }
            }
        });
    },

    _openDropdown: function (e) {
        var $thisList = $(this.element).children('.dropdown-list');

        $thisList
            .addClass('dropdown-show')
        .parent('.dropdown')
            .attr('aria-expanded', 'true');
    },

    _closeDropdown: function (e) {
        var $thisList = $(this.element).children('.dropdown-list');

        $thisList
            .removeClass('dropdown-show')
        .parent('.dropdown')
            .attr('aria-expanded', 'false');

        this._setDropdownToCurrentSelection();
    },

    // manually blur active/focus state from buttons/links
    _unfocus: function (e) {
        $(':focus').trigger('blur');
    },

    // test whether an element click on is a child of a dropdown
    _shouldCloseOnDocumentClick: function (e) {
        return !$(e.target).closest(".dropdown").length;
    },

    // select prev/next tabbable functions c/o:
    // https://github.com/marklagendijk/jquery.tabbable/blob/master/jquery.tabbable.js
    _selectNextTabbable: function () {
        var selectables = $(':tabbable');
        var current = $(':focus');
        var nextIndex = 0;

        // hardcoded this logic to select the next menu because browser tabindex is unreliable
        if (this.element.parents('.search-view').length > 0) {
            $('.search-sort .sel a').trigger('focus');
            return;
        }

        if (current.length === 1) {
            var currentIndex = selectables.index(current);
            if (currentIndex + 1 < selectables.length) {
                nextIndex = currentIndex + 1;
            }
        }

        selectables.eq(nextIndex).trigger('focus');
    },

    _selectPrevTabbable: function () {
        var selectables = $(':tabbable');
        var current = $(':focus');
        var prevIndex = selectables.length - 1;

        // hardcoded this logic to select the previous menu because browser tabindex is unreliable
        if (this.element.parents('.search-sort').length > 0) {
            $('.search-view .sel button').trigger('focus');
            return;
        }

        if (current.length === 1) {
            var currentIndex = selectables.index(current);
            if (currentIndex > 0) {
                prevIndex = currentIndex - 1;
            }
        }

        selectables.eq(prevIndex).trigger('focus');
    },

    // apply the correct classes/attributes on menu items
    _navigateMenu: function navigateMenu (e, key, $target) {
        var $listItem = $target.parents('.dropdown-item');
        var $dropdownList = $(this.element).find('.dropdown-list');
        var isLast;
        var isFirst;
        var $nextSelection;

        var isTabDown = (key === 9) && !e.shiftKey;
        var isTabUp = (key === 9) && e.shiftKey;

        // if down key or tab
        if (key === 40 || isTabDown) {
            isLast = $listItem.is(':last-child');

            // if already on the last item in the dropdown, tab out to the next tabbable thing
            if (isLast && isTabDown) {
                this._selectNextTabbable();
                this._closeDropdown();
                return;
            }

            $nextSelection = isLast ? $dropdownList.children().first() : $listItem.next();

        } else if (key === 38 || isTabUp) { // up arrow or shift+tab
            isFirst = $listItem.is(':first-child');

            // if on the first item in the dropdown, tab back to the next tabbable thing
            if (isFirst && isTabUp) {
                this._selectPrevTabbable();
                this._closeDropdown();
                return;
            }

            $nextSelection = isFirst ? $dropdownList.children().last() : $listItem.prev();
        } else {
            // return if valid keys are not found
            return;
        }

        // switch them buttons 'round
        $listItem
            .attr('aria-selected', false)
            .removeClass('sel')
            .trigger('blur');

        $nextSelection
            .attr('aria-selected', true)
            .addClass('sel')
        .children('button, a')
            .trigger('focus');
    },

    // reset the dropdown to the page's current view/sort selections
    // TODO: if dropdowns are used elsewhere on the site, this function will need to be customizable
    _setDropdownToCurrentSelection : function () {
        var $thisDropdown = $(this.element);
        var isSortDropdown = $thisDropdown.hasClass('dropdown-sort');
        var isViewDropdown = $thisDropdown.hasClass('dropdown-view');
        var currentSelection = $thisDropdown.find('.sel [data-selection]').data('selection');
        var currentView = CL.page.viewMode;
        // if the invisible sort input is not on the page, the default sort is by date ("newest")
        var currentSort = $thisDropdown.data('defaultSort') || 'date';

        if (!currentSelection) {
            // ¯\_(ツ)_/¯
            return;
        }

        var $currentItem;
        if (isViewDropdown && (currentSelection !== currentView)) {
            $currentItem = $('[data-selection=' + currentView + ']').closest('.dropdown-item');
        }

        if (isSortDropdown && (currentSelection !== currentSort)) {
            $currentItem = $('[data-selection=' + currentSort + ']').closest('.dropdown-item');
        }

        // if current item is set, that means the item selected on escape is not the same
        // as the current state of the page. set the menu to display the correct mode.
        if ($currentItem) {
            $thisDropdown
                .find('.dropdown-item')
                .attr('aria-selected', false)
                .removeClass('sel')
                .trigger('blur');

            $currentItem
                .attr('aria-selected', true)
                .addClass('sel')
                .children('button, a');
        }
    }
});
;
(function(){
    var popupTemplate; // will contain popup template string, to be gleaned from DOM
    var clusterTemplate; // will contain cluster marker template string, to be gleaned from DOM
    var postingTemplate; // will contain posting marker template string, to be gleaned from DOM
    var $popupContents;
    var $postingList;
    var $postingDetail;
    var $map = $('#map');

    var clusterCache = {};
    // decode currencySymbol in case it's an HTML entity or unicode reference
    var currencySymbol = $('<div>' + (window.currencySymbol || '') + '</div>').text();

    var contentToggle = function($container) {
        // one or the other will succeed
        $container.find('.viewcontainer').toggleClass('pics info');
        $container.filter('.viewcontainer').toggleClass('pics info');
    };

    var popupView = function(view){
        var views = ['posting', 'cluster'];
        var viewIndex = views.indexOf(view);

        if (viewIndex === -1){
            return;
        } else {
            delete views[viewIndex];
            views = views.join(' ');
        }

        $popupContents.addClass(view).removeClass(views);
    };

    var scaleDownLB = function(){
        var $lbframe = $('.lbframe');
        var top = parseInt($lbframe.css('top'), 10);
        var scale = 0;
        var value = '';
        var transform = {
            'transform': '',
            '-webkit-transform': '',
            '-ms-transform': ''
        };

        // box doesn't fit on screen, so scale it down
        if (top < 0){
            scale = 1 + ((top * 2) / $lbframe.height());
            value = 'scale(' + scale + ', ' + scale + ')';

            Object.keys(transform).forEach(function(prefix){
                transform[prefix] = value;
            });
        }

        // either add or remove scale
        $lbframe.css(transform);
    };

    var openPopup = function(marker){
        maps.activeMarker = marker;

        if (CL.page.isMobile) {
            CL.lightbox($popupContents, { afterCenter: scaleDownLB });
        } else {
            maps.openPopup = L.popup({
                    offset: L.point(1, -5),
                    // get out fron underneath zoom control box
                    autoPanPadding: [50, 5]
                }).
                setLatLng( marker.getLatLng() ).
                setContent( $popupContents[0] ).
                openOn( maps.map );
        }
    };

    var closePopup = function(){
        if (CL.page.isMobile) {
            CL.lightbox.close();
        } else if (maps.openPopup) {
            maps.map.closePopup( maps.openPopup );
        }
    };

    var toggleMapBubbleBanished = function(pid, isBanished) {
        var $postBubble = $('#postbubble');
        $postBubble.find( '.title' ).toggleClass( 'banished', isBanished );

        var $clusterBubble = $('#clusterbubble');
        $clusterBubble.find( '.posting[data-pid="' + pid + '"]' ).toggleClass( 'banished', isBanished );
    };

    // updated the banished / unbanished counts for the map marker icons and "# hidden" box
    CL.banish.events.on('banish unbanish', function(e, pid) {
        var markerInfo = maps.marker.containingPID[ pid ];

        if ( markerInfo ) {
            if ( e.type === 'banish' ) {
                markerInfo.banishedCount++;
                markerInfo.unbanishedCount--;
            } else if ( e.type === 'unbanish' ) {
                markerInfo.banishedCount--;
                markerInfo.unbanishedCount++;
            }

            maps.marker.updateIcon( pid );
        }

        if ( ! ( CL.page.viewMode !== 'map' || ! maps.openPopup || ! maps.activeMarker || maps.activeMarker.options.pids.indexOf( pid ) === -1 ) ) {
            if ( e.type === 'banish' ) {
                toggleMapBubbleBanished( pid, true );

                // additional behavior if user isn't showing banished postings
                if ( ! CL.page.showBanished ) {
                    if ( markerInfo.unbanishedCount === 0 ) {
                        /*
                          check to see if this posting is the final posting to be
                          banished for this marker. in the case of it being a single
                          posting marker, that's always true. in the case that it's one
                          posting in a server cluster of markers, it may or may not be
                          true.
                          if it is the final posting being banished, close the open popup
                        */
                        closePopup();
                    } else if ( markerInfo.banishedCount + markerInfo.unbanishedCount > 1 ) {
                        // if this posting is part of a cluster, go back to the cluster view
                        $('.backtolist').click();
                    }
                }
            } else if ( e.type === 'unbanish' ) {
                toggleMapBubbleBanished( pid, false );
            }

            maps.marker.updateIcon( markerInfo.marker );
        }
        CL.maps.countMarkers();
    });

    // function that activates handlers for single posting bubble view
    var makeAlive = function($dom, pid){
        // show fav star if available, and if it is a favorite update the map icon
        CL.favorites.init($dom.find('.icon-star'), function(){
            maps.marker.updateIcon( maps.activeMarker );
        });

        $dom.find('.contenttoggle a')
            // enable link to switch pic/info views
            .off('click touchstart')
            .on('click touchstart', function(e) {
                e.preventDefault();
                contentToggle($dom);
            });

        CL.swipe.makeGallery($dom);

        activateBanishControls( $dom, pid );

        $dom.find('.showcontact').on('click', function(e) {
            e.preventDefault();
            CL.page.showContactInfo(this.href);
        });
    };

    var toggleTitlePreview = function(){
        if (CL.maps.isFrozen) {
            return;
        }

        if ( this.title && this.marker && ! maps.openPopup ){
            maps.activeMarker = this.marker;
            maps.openPopup = L.popup({ offset: L.point(1, -5), closeButton: false, autoPan: false, isTitlePreview: true }).
                setLatLng(this.marker.getLatLng()).
                setContent('<div style="margin: -10px 0;">' + this.title + '</div>').
                openOn(maps.map);
        } else if (maps.openPopup && maps.openPopup.options.isTitlePreview) {
            closePopup();
        }
    };

    // make sure the banished items are so marked
    var activateBanishControls = function($dom, pid) {
        CL.banish.ready.done(function(){
            $dom.find( '.map-banish-unbanish' )
                .find( '.banish' ).off('click').on('click', { pid: pid }, function(e) {
                    CL.banish.ban( e.data.pid );
                    L.DomEvent.stopPropagation( e );
                }).end()
                .find( '.unbanish' ).off('click').on('click', { pid: pid }, function(e) {
                    CL.banish.unban( e.data.pid );
                    L.DomEvent.stopPropagation( e );
                });
            CL.maps.countMarkers();
        }).fail(function() {
            $dom.find( '.map-banish-unbanish' ).hide();
        });
    };

    var onClusterClick = function(e) {
        CL.maps.fullsizeMap();
        var cluster = this;
        var marker = e.target;
        maps.activeMarker = marker;
        var postingListContents = '';
        var clusterPopup = function($contents){
            $postingList.html($contents);
            popupView('cluster');
            openPopup(marker);

            // back button for getting from individual posting to clustered list
            $postingDetail.off('click').on('click', '.backtolist', function(){
                popupView('cluster');

                CL.lightbox.center();
                // if favorite state changed in posing view, reflect that in cluster view
                CL.favorites.init($postingList.find('.icon-star'), function(){
                    maps.marker.updateIcon(marker);
                });
            });

            // clicking on an entry in clustered list takes you to the posting view
            $postingList.off('click').on('click', '.posting', function(){
                var pID = $(this).addClass('visited').data('pid');

                var posting = postings(pID);

                // remember the listing has been clicked
                CL.jls.setItem(pID, 1);

                // put in the base template
                $postingDetail.html(posting.dom());
                popupView('posting');

                toggleMapBubbleBanished( pID, CL.banish.isBanished( pID ) );

                // load the rest of the posting, build it and then show that when finished
                posting.buildMapBubble(function(posting){
                    $postingDetail.html(posting.dom());
                    toggleMapBubbleBanished(pID, CL.banish.isBanished(pID));
                    makeAlive($postingDetail, pID);
                });

                if (CL.maps.openPopup) {
                    // make sure entire Leaflet popup is still in view
                    CL.maps.openPopup._adjustPan();
                } else {
                    CL.lightbox.center();
                }
            });

            $contents.each(function(i, posting) {
                var $posting = $(posting);
                var pid = $posting.data('pid');

                // mark currently banished postings accordingly
                toggleMapBubbleBanished( pid, CL.banish.isBanished( pid ) );
                activateBanishControls($posting, pid);
            });

            // init favstars for cluster list
            CL.favorites.init($postingList.find('.icon-star'), function(){
                maps.marker.updateIcon(marker);
            });
        };

        // show back to list button and header above postings
        $postingDetail.addClass('iscluster');

        // add the user's search params, but skip ones that are
        // meaningless in geocluster requests
        var geocluster_inapplicable_params = ['s']; // s= is pagination
        var query_params = CL.url.params();
        geocluster_inapplicable_params.forEach(function(key) {
                delete query_params[key];
            });
        var url = decodeURI(cluster.url + '&' + $.param(query_params));

        // remember marker was clicked
        var pID = this.PostingID;
        var geoCluster = this.GeoCluster;
        CL.jls.setItem(geoCluster, pID);
        marker.options.visited = true;
        maps.marker.updateIcon(marker);

        // pull cluster info from cache or fetch it from the server
        if (clusterCache[url]){
            clusterPopup(clusterCache[url]);
        } else {
            $.getJSON(url).done(function(postingList){
                var $contents;

                postingList[0].forEach(function(p){
                    p.visited = CL.jls.getItem(p['PostingID']) ? 'visited' : '';
                    // convert from img0,img1,img2,... -> img0
                    if (p.ImageThumb && p.ImageThumb.indexOf(',') > 0) {
                        var imgList = p.ImageThumb.split(',');
                        p.ImageThumb = imgList[0] + '_50x50c.jpg';
                    }
                    // prevent any broken thumbnails
                    if (! p.ImageThumb) {
                        p.ImageThumb = '/images/peace-sm.jpg';
                    }
                    // cache the posting data
                    postings(p.PostingID).data(p);
                    postingListContents += L.Util.template(clusterTemplate, p);
                } );

                $contents = $(postingListContents);
                clusterCache[url] = $contents;

                clusterPopup($contents);
            });
        }

    };

    var onMarkerClick = function (e) {
        CL.maps.fullsizeMap();

        var pID = this.PostingID;
        var posting = postings(pID);

        if (!posting.data()){
            posting.data(this);
        }

        var marker = e.target;
        maps.activeMarker = marker;

        marker.options.visited = true;
        maps.marker.updateIcon(marker);

        // make sure there is no 'back to cluster' header above posting
        $postingDetail.removeClass('iscluster');

        // remember the marker has been clicked
        CL.jls.setItem(pID, 1);

        // put in the base template
        $postingDetail.html(posting.dom());
        popupView('posting');
        openPopup(marker);

        toggleMapBubbleBanished(pID, CL.banish.isBanished(pID));
        activateBanishControls( $postingDetail, pID );

        // load and build the rest of the posting, shove it in the DOM and wire it up
        posting.buildMapBubble(function(posting){
            $postingDetail.html(posting.dom());
            toggleMapBubbleBanished(pID, CL.banish.isBanished(pID));
            makeAlive($postingDetail, pID);
        });
    };

    var maps = CL.maps;

    var adjustPopupPan = function() {
        // hacky use of Leaflet's internal stuff
        // if there is an open popup, make sure it's still visible after map resize
        if (maps.openPopup && maps.openPopup._map){
            maps.openPopup._adjustPan();
        }
    };

    var postings = (function(){
        var pList = {};

        var P = function(postingID){
            var id = postingID;

            if (!pList[id]){
                pList[id] = {};
            }

            this.id = function(){
                return id;
            };
        };

        P.prototype.buildMapBubble = function(callback){
            var posting = pList[this.id()];
            var self = this;

            var digestPostingPage = function(data){
                var imgList, $data, $postingBody, $attrsGrp, $bigatt;

                // try to get the image list if present
                imgList = data.match(/imgList\s+=\s+(\[[^\]]*\])/);
                if (imgList && imgList.length === 2) {
                    try {
                        imgList = JSON.parse(imgList[1]);
                    }
                    catch (e) {
                        imgList = [];
                    }
                } else {
                    imgList = [];
                }

                // we want to use medium-sized thumbs, not full images
                // TODO - do we want to push the 300x300 URL into the HTML
                // which is bloatier, or calc it here which is uglier?
                imgList = imgList.map( function(img) {
                    return ( img.url || '' ).replace(/600x450/, '300x300');
                });

                $data = $(data);
                $postingBody = $data.find('#postingbody');
                $postedDate = $data.find('#display-date time');
                $attrsGrp = $data.find('.attrgroup');
                $bigatt = $data.find('.bigattr');
                // if there's no #postingbody, it's probably expired or flagged so grab that info instead
                if ($postingBody.length === 0){
                    $postingBody = $data.find('.userbody');
                }

                return { imgList: imgList, $postingBody: $postingBody, $attrs: $attrsGrp, $bigattr: $bigatt, $postedDate: $postedDate };
            };

            if (!posting.data.fullyLoaded){
                $.get(posting.data.PostingURL).done(function(postingPage){
                    var postInfo = digestPostingPage(postingPage);
                    var imgList = postInfo.imgList;

                    posting.data.imgList = imgList;
                    posting.dom.find('.infocontainer').append(postInfo.$attrs, postInfo.$bigattr, postInfo.$postingBody);
                    posting.dom.find('.timecontainer').replaceWith(postInfo.$postedDate);

                    if (imgList.length) {
                        // if there are images, make them into a gallery, but not on IE6--
                        if (CL.browser.ieVersion < 7) {
                            return;
                        }
                        posting.dom.find('.swipe-wrap').
                            html(
                                imgList.map(function(img){ return '<div><img src="' + img + '" /></div>'; }).
                                join('')
                            );
                        posting.dom.find('.contenttoggle').show();
                    } else {
                        // swipe code looks for this container so if it's not there, it won't run (which is good)
                        posting.dom.find('.swipe').remove();
                        // and just show the ad text
                        contentToggle(posting.dom);
                    }

                    posting.dom.removeClass('loading');

                    posting.data.fullyLoaded = true;

                    if (typeof callback === 'function'){
                        callback(self);
                    }
                });
            } else {
                if (typeof callback === 'function'){
                    callback(self);
                }
            }

            return self;
        };

        P.prototype.clear = function(){
            pList[this.id()] = {};

            return this;
        };

        P.prototype.data = function(data){
            var posting = pList[this.id()];

            if (data){
                posting.data = posting.data || {};

                data.currencySymbol = currencySymbol;
                // don't show price if undefined or '', but do show if 0 or '0', etc.
                data.hasPrice = (!data.Ask && data.Ask !== 0) ? 'no' : '';
                data.BedroomsContent = data.Bedrooms ? data.Bedrooms + 'BR' : '';

                // always an update. to replace, call .clear().data(...)
                $.extend(posting.data, data);
                // updating data re-caches dom
                posting.dom = $(L.Util.template(postingTemplate, posting.data))
                    // add pid to favstar
                    .find('.icon-star').data('pid', this.id()).end();

                return this;
            } else {
                return posting.data;
            }
        };

        P.prototype.dom = function(){
            var posting = pList[this.id()];

            return posting.dom.clone();
        };

        return function(id){
            return new P(id);
        };
    }());

    var drawOrRedrawMap = function (latlng, zoom) {
        if (! maps.map) {
            maps.map = new L.Map('map', {
                center: latlng,
                zoom: zoom,
                minZoom: 1,
                maxZoom: 17,
                maxBounds: [ [-90, -180], [90, 180] ],
                layers: [maps.tilelayer],
                zoomControl: false
            });

            // add zoom control that has full screen button as well
            CL.maps.controls = {};
            var fullsize = new L.Control.ZoomFS();
            CL.maps.controls.fullsize = fullsize;
            maps.map.addControl(CL.maps.controls.fullsize);
            $('.close-full-screen-map-mode-button').on('click', function(){
                fullsize.fullscreen();
            });

            // map scale control on lower right
            var scale = L.control.scale({
                metric: window.areaCountry !== 'US',
                imperial: window.areaCountry === 'US',
                updateWhenIdle: true
            });
            maps.map.addControl(scale);

            // mandatory attribution
            maps.map.attributionControl.setPrefix('');

        } else {
            maps.map.setView(latlng, zoom);
        }
    };

    // true if all children visited
    var zoomToMarkerList = {};
    var getMapData = function (geosearchURL) {

    // first draw map at area center and default zoom.
    var $container = $('#mapcontainer');
    var latlng = new L.LatLng( $container.data('arealat'), $container.data('arealon') );
    var defaultzoom = 10;
    drawOrRedrawMap(latlng, defaultzoom);

        $.getJSON( geosearchURL ).done(function(data) {
            // wait until localStorage availability is determined so favorites stuff can proceed smoothly
            CL.when.localStorageAvailable.always(function(){
                var markers = data[0];
                var otherInfo = data[1];

                // IOS7 work around - RT#23675
                var length = markers.length;
                var ios7MaxMarkerCount = 500;
                if (navigator.userAgent.match(/iPhone OS 7/) && length > ios7MaxMarkerCount) {
                    markers.length = length = ios7MaxMarkerCount;
                }

                // center and zoom calculated by server
                if (length > 0) {
                    var latmean  = otherInfo['clat'];
                    var lonmean = otherInfo['clng'];
                    latlng = new L.LatLng(latmean, lonmean);
                    var zoom85pct = otherInfo['zoom'];

                    if (zoom85pct > 1) {
                        defaultzoom = zoom85pct;
                    } else {
                        defaultzoom = 15;
                    }

                    if (defaultzoom > 17) {
                        defaultzoom = 17;
                    }
                }

                // reposition map from server data
                drawOrRedrawMap(latlng, defaultzoom);

                // range search so draw circle
                if (postalLat && postalLon && searchDistance > 0) {
                    L.circle([ postalLat, postalLon ], searchDistance, {
                        color: '#777777',
                        weight: 1,
                        fillOpacity: 0.07
                    }).addTo(maps.map);
                }

                // create a layer that will automatically cluster markers
                // together at varying zoom levels
                var markerClusterGroup = new L.MarkerClusterGroup({
                    chunkedLoading: true,
                    chunkInterval: 100,
                    zoomToBoundsOnClick: false,
                    spiderifyOnMaxZoom: false,
                    showCoverageOnHover: false,
                    animate: false,
                    maxClusterRadius: 64,
                    disableClusteringAtZoom: 17,
                    iconCreateFunction: function(cluster) {
                        var totalCount = 0;
                        var unbanishedCount = 0;
                        var isAllVisited = false;

                        cluster.getAllChildMarkers().forEach(function(marker){
                            totalCount += marker.options.numposts;
                            isAllVisited = isAllVisited || marker.options.visited;
                            unbanishedCount += maps.marker.containingPID[ marker.options.pids[0] ].unbanishedCount;
                        });

                        // if unbanishedCount isn't yet defined in maps.marker.containingPID, just display the total number of markers instead
                        if ( isNaN( unbanishedCount ) ) {
                            unbanishedCount = totalCount;
                        }

                        return maps.makeIcon({
                            unbanishedCount: unbanishedCount,
                            totalCount: totalCount,
                            visited: isAllVisited,
                            cluster: true,
                            // not showing fav colors cluster markers, for now
                            fav: false,
                            marker: cluster
                        });
                    }
                });

                markerClusterGroup.on('clusterclick', CL.maps.fullsizeMap);

                var total = 0;
                var markerList = [];
                var numItemsShown = 0;

                for (var i = 0; i < length; i++) {
                    var a = markers[i];

                    var markerVisited, marker, pids;
                    var postCount = Number( a['NumPosts'] ) || 1;
                    var pid = a['PostingID'];
                    var previewTitle = '';

                    if (postCount > 1) {
                        // cluster marker
                        markerVisited = ( CL.jls.getItem(a['GeoCluster']) == pid );
                        pids = pid.split(',').map(Number).sort();
                        total += postCount;

                        marker = CL.maps.marker.create(
                            a['Latitude'], a['Longitude'],
                            {
                                visited: markerVisited,
                                numposts: postCount,
                                posteddate: a['PostedDate'] * 1000,
                                pids: pids
                            }
                        );

                        marker.on('click', onClusterClick, a);
                    } else {
                        markerVisited = ( CL.jls.getItem( pid ) !== null );
                        pids = [ Number(pid) ];
                        total++;
                        // previewTitle is for hovering purposes only
                        previewTitle = a['Ask'] ? '<span class="price">' + currencySymbol + a['Ask'] + '</span> - ' : '';
                        previewTitle += a['PostingTitle'];

                        marker = CL.maps.marker.create(
                            a['Latitude'], a['Longitude'],
                            {
                                visited: markerVisited,
                                numposts: 1,
                                posteddate: a['PostedDate'] * 1000,
                                pids: pids
                            }
                        );

                        marker.on('click', onMarkerClick, a)
                            .on('mouseover', toggleTitlePreview, { title: previewTitle, marker: marker })
                            .on('mouseout', toggleTitlePreview);
                    }

                    maps.marker.updateIcon(marker);

                    zoomToMarkerList[ pid ] = marker;

                    markerList.push(marker);
                    numItemsShown++;
                }

                markerClusterGroup.addLayers(markerList);

                var $mapcontainer = $('#mapcontainer');
                if (numItemsShown === 0) {
                    // default is area center
                    var $noResults = $('#noresult-overlay, #noresult-text');
                    $noResults
                    // vertical centering
                        .css('line-height', $mapcontainer.height() + 'px')
                        .addClass('visible')
                        .on('click', function() {
                            $noResults.removeClass('visible');
                        });
                }

                maps.map.addLayer(markerClusterGroup);
                CL.maps.countMarkers();

                // show cursor as crosshairs on map while holding shift because shift lets you draw a box to zoom
                $map.removeClass('loading');
                // click on open popup to close
                maps.map.on('popupopen', function(e) {
                    if (e.popup === maps.openPopup) {
                        e.popup._close(1);
                        maps.openPopup = undefined;
                    }
                }).on('popupclose', function() {
                    maps.openPopup = undefined;
                }).on('enterFullscreen', function() {
                    adjustPopupPan();
                }).on('exitFullscreen', function() {
                    if (CL.page.isMobile) {
                        if (!CL.page.oldMode || CL.page.oldMode == 'map') {
                            CL.page.oldMode = window.defaultView;
                        }
                        $('.close-map-view-button').trigger('click');
                    } else {
                        adjustPopupPan();
                        CL.maps.countMarkers();
                    }
                }).on('moveend', function() {
                    CL.maps.countMarkers();
                });

                // handle marker cluster click
                var zoomHalfway = function (a) {
                    var new_center = a.latlng;
                    var map_zoom = maps.map.getZoom();
                    var marker_zoom = maps.map.getBoundsZoom(a.layer.getConvexHull());
                    var new_zoom = map_zoom + Math.round((marker_zoom - map_zoom) / 2);
                    maps.map.setView(new_center, new_zoom);
                };
                markerClusterGroup.on('clusterclick', zoomHalfway);

                // let anyone who cares know that the map is ready
                CL.maps.ready.resolve(maps.map);
            });
        } );
    };

    CL.extend('maps', {
        init: function() {
            popupTemplate = $('#popuptemplate').html().trim();
            clusterTemplate = $('#clustertemplate').html().trim();
            postingTemplate = $('#postingtemplate').html().trim();
            $popupContents = $(popupTemplate);
            $postingList = $popupContents.find('#clusterbubble');
            $postingDetail = $popupContents.find('#postbubble');

            // propagating events can close the map bubble in some instances (IE8 for example)
            $popupContents.on('click', function(e){
                e.stopPropagation();
            });

            // if the device is rotated, make sure any open lightbox stays centered
            $(window).on('resize', function(){
                CL.lightbox.center();
            });

            $(document).on('keydown', function(e){
                if (e.shiftKey) {
                    $map.addClass('xhair');
                }
            }).on('keyup', function(e){
                if (!e.shiftKey) {
                    $map.removeClass('xhair');
                }
            });

            L.Icon.Default.imagePath = '//www.craigslist.org/images/map/';

            maps.tilelayer = new L.TileLayer(maps.clMapsUrl, {
                subdomains: "0123456789",
                setView: true,
                enableHighAccuracy: true,
                attribution: '&copy; craigslist - Map data &copy; ' +
                    '<a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> - ' +
                    '<a href="https://forums.craigslist.org/?forumID=3132">Report a problem</a>'
            });

            // generate geosearchURL from category and subarea data
            var searchURL = [ 'jsonsearch', window.catAbb || 'fav' ];
            if (window.subarea) {
                searchURL.push(window.subarea);
            }
            // append the rest of the query string
            searchURL.push(window.location.search);
            var geosearchURL = decodeURIComponent('/' + searchURL.join('/'));
	    if (geosearchURL.indexOf('?') == -1) {
		geosearchURL = geosearchURL + '?map=1';
	    } else {
		geosearchURL = geosearchURL + '&map=1';
	    }
            getMapData(geosearchURL);

            // only run this function once
            CL.maps.init = CL.util.noop;
        },
        countMarkers: function() {
            // this function counts markers visible on the map (within viewport and
            // considering banished status) and updates the display count
            var map = CL.maps.map;
            if ( ! map || CL.page.viewMode !== 'map' ) {
                return;
            }
            var byID = CL.maps.marker.byID;

            var showCount = 0;

            var bounds = map.getBounds();

            // check all markers
            Object.keys( byID ).forEach(function(id){
                var markerInfo = byID[ id ];

                if ( bounds.contains( markerInfo.marker.getLatLng() ) ){
                    showCount += markerInfo.unbanishedCount;
                }
            });

            $( '.displaycountShow' ).text( showCount );
        },
        ready: new $.Deferred(),
        zoomToPosting: function(pid) {
            this.ready.done(function(map){
                var marker = zoomToMarkerList[pid];

                if (!marker || !map) {
                    return;
                }

                map.setView(marker.getLatLng(), 17, { animate: false });
                marker.fireEvent('click');
            });
	},
	fullsizeMap: function() {
            $('button#mapview').click();
            $('ul.dropdown-list').removeClass('dropdown-show'); // close dropdown menu on touch devices
            if ($('.leaflet-control-zoom').length) {
                CL.maps.map.removeControl(CL.maps.controls.fullsize);
            }
            if (CL.maps.map) {
                CL.maps.map.addControl(CL.maps.controls.fullsize);
            }
            $('#mapcontainer').css({
                height: '99%'
            });
            CL.maps.thawMap();
        },
        inlineMap: function() {
            CL.maps.init();
            CL.maps.map.removeControl(CL.maps.controls.fullsize);
            $('#map').on('click', CL.maps.fullsizeMap);
            CL.maps.freezeMap();
	}
    });
}());
;
(function(){

    // avoid running all this code if we are simply preloading the file
    var $body = $('body');
    if ( ! $body.hasClass('search') ){
        return;
    }

    $('span.icon-locate').on('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
	reverseGeocodeUser({
            onSuccess: function(data) {
                var loc = data[0];
                var $postal = $('input.postal');
                var $dist = $('input.search_distance');
                $postal.val(loc.postal);
                $dist.val(Math.round(loc.radius));
                $('button.searchbtn').click();
            },
            onError: function(msg) { alert(msg) },
            extra: { src: 'sr' }
        });
    });

    /*
      Search Nearby is a check box that autosubmits. When checked, a number of nearby area
      checkboxes are made visible below it. The state of these checkboxes is stored
      in the local storage for this site ( ie : sfbay rather than www ).

      Clicking on a nearby area sets and saves that preference data, and then acts
      like any control : when it's state is changed, it highlights and highlights the
      search button.
     */
    var chosenLocals = {};
    var $searchNearby = $( 'input[name=searchNearby]' );
    var $searchNearbyAreaChecks = $( '.nearbyAreas' ).find('input[name=nearbyArea]');

    var $nearbyNumber = $( '#nearbyNumber' );
    var $nextNearbyZone = $( '.nextNearbyZone' );
    $nextNearbyZone.on( 'click', function() {
        var $this = $(this);
        var zone = Number($this.data( 'zone' ));
        $( '.nearbyZone.nearbyZone_' + zone ).removeClass( 'nearbyZone' );
        if ( $('.nearbyZone' ).length ) {
            var number = 0;
            while( number === 0 && zone < 4) {
                zone++;
                number = $( '.nearbyZone.nearbyZone_' + ( zone) ).length;
                $this.data( 'zone', zone );
            }
            $nearbyNumber.text( number );
        } else {
            $this.hide();
        }
    });

    // this toggles showing and hiding the duplicates that are gathered together.
    $( '.duplicate-row' ).each( function() {
        var $dup = $(this);
        var $pouch = $dup.find( '.duplicate-rows' );
        $dup.find( '.expand' ).on('click',function(e) {
            e.preventDefault();
            e.stopPropagation();
            $dup.toggleClass('expanded');
            if( $dup.hasClass( 'expanded' ) && CL.page.viewMode === 'grid' ) {
                $pouch.find( '.result-row' ).each(function(i,el) {
                    CL.swipe.makeGallery($(el));
                } );
            }
        } );
        // clicking the trash on the collapsing row banishes all 
        // items collapsed inside of it
        $dup.find( '.collapsed-trash' ).on('click', function(e) {
            e.stopPropagation();
            e.preventDefault();
            CL.banish.ban( $dup.data('pid') );
            $dup.find( '.result-row' ).each( function( idx, row) {
                CL.banish.ban( $(row).data('pid') );
            } );
            $dup.detach();
            updateBanishedCounter();
        } );
    } );


    CL.when.localStorageAvailable.done(function(){
        chosenLocals = CL.jls.getItem('chosenLocals');

        var hasChosenLocals = chosenLocals && Object.keys(chosenLocals).length > 0;

        chosenLocals = chosenLocals || {};
        if ( $searchNearby.is(':checked') ) {
            $searchNearbyAreaChecks.each( function() {
                var $this = $(this);
                if( hasChosenLocals ) {
                    if ( chosenLocals[ $this.val() ] === true ) {
                        $this.parent().parent().removeClass('nearbyZone');
                        $this.attr('checked','checked');
                    } else if ( typeof chosenLocals[ $this.val() ] === 'boolean' ) {
                        $this.removeAttr('checked');
                    }
                }
            } );
        }
        $nearbyNumber.text( $( '.nearbyZone.nearbyZone_' + $nextNearbyZone.data('zone') ).length );

        // override autosubmit behavior on searchNearby control
        // this gives a chance for areas that were rejected or were extra included to be passed forwards
        $searchNearby.removeClass( 'autosubmit' );
        $searchNearby.off('click').on('click', function() {
            $( '.nearbyArea' ).each( function() {
                $( this ).removeAttr( 'disabled' );
            } );
            $searchform.submit();
        });
    });

    $searchNearbyAreaChecks.each( function() {
        var $this = $(this);
        $this.on( 'click', function() {
            var area_id = $this.val();
            if ( $this.is(':checked') ) {
                chosenLocals[ area_id ] = true;
            } else {
                chosenLocals[ area_id ] = false;
            }
            CL.jls.setItem('chosenLocals',chosenLocals);
        } );
    });

    var $banishedCount      = $('.banished_count');
    var $banishedCountShown = $('.banished_count_shown');
    var $banishedMismatch   = $( '.banish-out-of' );
    var $noBanishedMismatch = $( '.banish-count-only' );
    var isBanishedPage      = $( '.my-banished' ).length === 1;

    if (isBanishedPage) {
        // this is showing the banished items, so hijack the category
        // a hrefs so that we are not sending GET requests. For banished
        // we want POST requests
        $( '.category' ).each( function() {
            var $thischeck = $( this );
            $thischeck.off( 'click' ).on( 'click', function( e ) {
                e.stopPropagation();
                e.preventDefault();
                $( '#categories-hidden' ).val( $thischeck.prev().attr('value') );
                $( '#searchform' ).submit();
            } );
        } );
    }

    var updateBanishedCounter = function() {
        var banishedCount = CL.banish.banishedCount();

        $banishedCount.text( banishedCount );
        $banishedCountShown.text( $( '.banished' ).length  );
        $banishedMismatch.toggle( banishedCount !== parseInt( $( '.banished' ).length, 10 ) );
        $noBanishedMismatch.toggle( banishedCount === parseInt( $( '.banished' ).length, 10 ) );

        $( '.unfaves' ).attr( 'value', CL.banish.encode() );

        $body.toggleClass( 'has-banished', Boolean( banishedCount ) );

        // no more banished items, revert to default of hiding banished items
        if ( banishedCount === 0 && CL.page.viewMode !== 'map' ) {
            CL.banish.hide();
        }
    };

    var processResultsForBanishment = function (event) {
        $( '.result-row' ).each( function() {
            var $row = $( this );
            var pid = $row.data( 'pid' );
            var repostOf = $row.data( 'repost-of' );

            if (CL.banish.isBanished(pid) || CL.banish.update(repostOf, pid)) {
                $row.addClass('banished');
            }

            if (isBanishedPage && !CL.banish.isBanished(pid)) {
                $row.removeClass('banished').addClass('restored');
            }
        });

        // if there are duplicate roll ups, check to make sure their counters are correct
        $( '.duplicate-row' ).each( function() {
            var $dup = $(this);
            var $pouch = $dup.find( '.duplicate-rows' );
            var $expFirst = $dup.find('.expand.first');
            var $et = $expFirst.find( '.expand-toggle' );
            var $rows = $pouch.find( '.result-row' );
            $rows.each( function() {
                var $this = $( this );
                $this.find( '.icon-trash' ).on('click', function() {
                    CL.banish.ban( $this.data( 'pid' ) );
                    var nowcount = $et.text() - 1;
                    $et.text( nowcount );
                    if( nowcount === 0 ) {
                        $dup.find('.expand.first').detach();
                    }
                } );
            } );
            var $unBanned = $pouch.find( '.result-row' ).not( '.banished' );
            var unBannedLength = 1 + $unBanned.length;

            if ( $dup.hasClass( 'banished' ) ) {
                unBannedLength--;

                // okey, crazy time, have to shuffle the the first unbanned 
                // out of the pouch, then put the pouch in it, and replace
                // the old dup with it. again, this is the case where the 
                // first of the duplicates was banned, but not all of the 
                // duplicates were banned
                if( unBannedLength > 0 ) {
                    var $first = $( $unBanned[0] ).detach();

                    $first.addClass( 'duplicate-row' );
                    $pouch = $pouch.detach();
                    $expFirst = $expFirst.detach();

                    $dup.replaceWith( $first );

                    $pouch.insertAfter( $first.find( '.result-info' ) );
                    $($first.find('span.banish.icon')[0]).after( $expFirst );
                    $first.find('.expand').off('click').on('click',function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $first.toggleClass( 'expanded' );
                    } );
                    var $trash = $( $first.find( '.icon-trash' )[0] );
                    $trash.addClass( 'collapsed-trash' );
                    $trash.off('click').on('click', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        CL.banish.ban( $first.data('pid') );
                        $first.find( '.result-row' ).each( function( idx, row) {
                            CL.banish.ban( $(row).data('pid') );
                        } );
                    } );
                }
            } 
            if ( unBannedLength === 1 ) {
                $expFirst.detach();
            } else if ( unBannedLength === 0 ) {
                $dup.detach();
            } else {
                $et.text( unBannedLength - 1 );
            }
        } );

        updateBanishedCounter();
    };

    // add the banished class to all rows known to be banished
    CL.banish.ready.done(function(){

        // click handlers
        $body.on('click', '.banish', function(e){
            e.stopPropagation();
            e.preventDefault();
            CL.banish.ban( $(this).closest('.result-row').data('pid') );
        });

        $body.on('click', '.unbanish, .restore-link', function(e) {
            CL.banish.unban( $(this).closest('.result-row').data('pid') );
            e.stopPropagation();
            e.preventDefault();
        });

        $( '.mobile-discards, .discards, .map .favlink' ).on( 'click', function(ev) {
            if ( CL.browser.hashChange ) {
                if ( CL.page.showBanished ) {
                    history.back();
                }
            } else {
                if ( CL.page.showBanished ) {
                    CL.banish.hide();
                } else {
                    CL.banish.show();
                }
            }
        });

        // get search key to report context to server upon [un]banishment
        var searchKey = streamSearch ? encodeURIComponent(streamSearch.curSearch()) : '';

        // hide/unhide event listeners
        CL.banish.events.on('banish unbanish', function(e, pid) {
            // banishment can happen in map view, so only take action on the .row involved if it exists on the page
            var $row = $('.result-row[data-pid=' + pid + ']');

            // build url to send the flag to
            var sendURL;
            if (e.type === 'banish') {
                sendURL = "/flag/?async=async&flagCode=35&postingID=" + pid;    // banish flag
            } else {
                sendURL = "/flag/?async=async&flagCode=36&postingID=" + pid;    // unbanish flag
            }

            if (searchKey) {
                sendURL += '&search=' + searchKey;
            }

            if ($row.length) {
                // unfavorite the result if hidden from the favorites page
                if (e.type === 'banish' && CL.favorites.isFavorite(pid)) {
                    $row.find('.icon-star').trigger('click');
                }

                // send a server flag for hide/unhide events
                $.get(sendURL);

                if (e.type === 'banish') {
                    $row.addClass('banished');
                } else {
                    $row.removeClass('banished').addClass('restored');
                }
            }

            updateBanishedCounter();
        });

        // on load, loop every .result-row, check banished state, and apply necessary transformations
        processResultsForBanishment();

        // this is a <a> but we want it to work like a submit button
        $( '.to-banish-page-link' ).off('click').on('click', function( e ) {
            e.stopPropagation();
            e.preventDefault();
            $( '.unfavform' ).submit();
        } );
    })
    .fail(function() {
        $('.banish-unbanish').hide();
    });

    var SearchURL = function(pathString){
        // get path parts and filter out empty strings
        var path = (pathString || window.location.pathname).replace(/\/d\/[^\/]*/g, '').split('/').filter(Boolean);
        // root is always first
        var root = path.shift();

        // the purpose of deriving props from origValues is so that getters will always return accurate
        // values even if setters haven't been called. e.g. .area() will return the area so you can
        // test against it, but it won't come out in the final string if the setter .area('newarea')
        // hasn't been called, or you can call .purveyor() to check if the current category is owner /
        // dealer / all without having set the property explicitly, etc.
        var origValues = {
            // category is always last
            category: path.pop(),
            // if anything is left, that's the subarea
            subArea: path.pop(),
            area: window.location.hostname.split('.')[0],

            isSearch: root === 'search',
            isFavorites: root === 'favorites',
            purveyor: undefined
        };

        if (window.purveyorCategories) {
            Object.keys(window.purveyorCategories).some(function(this_purveyor) {
                if (window.purveyorCategories[this_purveyor] === origValues.category) {
                    origValues.purveyor = this_purveyor;
                    return 1;
                }
            });
        }

        var props = Object.create(origValues);
        var propExists = function(name){
            if (props.hasOwnProperty(name)) {
                return props[name];
            }
        };

        var self = {
            category: function(cat){
                if (typeof cat === 'undefined') {
                    return props.category;
                }

                props.category = cat;
                return self;
            },
            subArea: function(sa){
                if (typeof sa === 'undefined') {
                    return props.subArea;
                }

                props.subArea = sa;
                return self;
            },
            area: function(a){
                if (typeof a === 'undefined') {
                    return props.area;
                }

                props.area = a;
                return self;
            },
            purveyor: function(type){
                if (typeof type === 'undefined') {
                    return props.purveyor;
                }

                // Temporary hack to cope with the old perverse
                // abbreviations while this ship clobbers out.
                // TODO: Remove afterward.
                var legacy_purveyors_map = {
                    'o': 'owner',
                    'd': 'dealer',
                    'a': 'all'
                };
                if (legacy_purveyors_map[type]) {
                    type = legacy_purveyors_map[type];
                }

                var valid_purveyors = {
                    'owner': 1,
                    'dealer': 1,
                    'all': 1
                };
                if (! valid_purveyors[type]) {
                    throw new Error('Invalid purveyor type! Must be one of: ' + Object.keys(valid_purveyors).join(' '));
                }

                props.purveyor = type;
                return self;
            },
            // for isSearch and isFavorites, it only makes sense to pass in a truthy value
            // it's never going to be the case that you know it's *not* a particular type
            // without knowing that is *is* a different type
            isSearch: function(flag){
                if (flag) {
                    props.isSearch = Boolean(flag);
                    props.isFavorites = false;
                    return self;
                } else {
                    return props.isSearch;
                }
            },
            isFavorites: function(flag){
                if (flag) {
                    props.isFavorites = Boolean(flag);
                    props.isSearch = false;
                    return self;
                } else {
                    return props.isFavorites;
                }
            },
            toString: function(){
                var host = '';
                var path = [];

                // changing areas means we need a FQDN, otherwise output will be a path only
                if (propExists('area')) {
                    host = '//' + props.area + '.' + CL.url.baseDomain;
                }

                if (props.isSearch) {
                    if (window.purveyorCategories && propExists('purveyor') && window.purveyorCategories[props.purveyor]) {
                        props.category = window.purveyorCategories[props.purveyor];
                    }

                    path = [ 'search', props.subArea, props.category ];
                } else if (props.isFavorites) {
                    path = [ 'favorites' ];
                }

                // clean out any undefined elements
                path = path.filter(Boolean);
                // make sure there's a leading /
                path.unshift('');

                return host + path.join('/');
            }
        };

        return self;
    };

    /* this function takes a set of values that is a diff-from-previous set, and returns
       an object that can be used to retrieve the set as a diff string, diff array, or
       reconstituted array. the arrays returned are copies to avoid altering the originial set.
       For example, if created with the diffstring 120-1-40, it decompresses into [ 120, 121, 161 ].
       internally this stores the decomprssed values. it translates back to a diffstring.
       values can be added to it. If a value added was already present, the resulting
       diff string will be unchanged.
    */
    var diffSet = function(params) {
        /*
            params: {
                values: [String or Array] list of numbers that are diffed or shall be diffed
                delimiter: [String] if values is a string, which delimiter is or shall be used
                    Default: '-'
                isUncompressed: [Boolean] indicates if values is already diffed (true), or to be diffed (false)
                    Default: false
            }
        */

        // - is a nice, url-safe choice
        var delimiter = params.delimiter || '-';
        var values = [];

        // params.values can be a string or an array
        if (typeof params.values === 'string') {
            values = params.values.trim();
            values = values ? values.split(delimiter).map(Number) : [];
        } else if ( params.values && params.values.length ) {
            values = params.values.map( Number );
        }
        var real_values;
        //translate if needed
        if ( params.isUncompressed ) {
            real_values = values;
        } else {
            if ( values.length > 0 ) {
                real_values = [ values[0] ];
                for( var i=1; i<values.length; i++ ) {
                    real_values.push( real_values[ i - 1 ] + values[ i ] );
                }
            } else {
                real_values = [];
            }
        }
        real_values = real_values.sort(function(a,b){ return a - b; });
        return {
            real_values : real_values,

            add: function( ns ) { // add a list of numbers to this excats
                var that = this;
                ns.map( Number ).map( function(n) { that.real_values.push( n ); } );
                this.real_values = this.real_values.sort(function(a,b){ return a - b; });
                return that;
            },

            remove: function( ns ) { // remove a list of numbers to this excats
                ns = ns.map( Number );
                var remover = {};
                for( var i=0; i<ns.length; i++ ) {
                    remover[ ns[i] ] = true;
                }
                var that = this;
                var new_real = [];
                for( i=0; i<that.real_values.length; i++ ) {
                    if ( ! remover[ that.real_values[ i ] ] ) {
                        new_real.push( that.real_values[ i ] );
                    }
                }
                new_real = new_real.sort(function(a,b){ return a - b; });
                this.real_values = new_real;
                return that;
            },

            asDiffArray: function(){
                if ( this.real_values.length === 0 ) {
                    return [];
                }
                var da = [ this.real_values[ 0 ] ];
                for( var i=1; i<this.real_values.length; i++ ) {
                    var diff = this.real_values[ i ] - this.real_values[ i - 1 ];
                    if ( diff > 0 ) {
                        da.push( diff );
                    }
                }
                return da;
            },
            asDiffString: function(){
                return this.asDiffArray().join( delimiter );
            },
            asFullArray: function(){
                return this.real_values.slice(0);
            }
        };
    };

    var $window = $(window);

    var $searchform = $('#searchform');
    var searchformAction = new SearchURL();
    var $searchInputs = $searchform.find('input, select, .searchInput');
    var $query = $('#query');
    var $categoryInputs = $('.categories').find('input[type=checkbox]').not('.selectallcb').removeAttr('name');

    (function(){
        /*  cut out the sending of any inputs that aren't required to
            perform the search. this will clean up / shorten search URLs
        */
        var includeIfNeeded = function($el, needed){
            if (needed) {
                $el.renameAttr('data-name', 'name');
            } else {
                $el.renameAttr('name', 'data-name');
            }
        };

        var sanitizeInput = function($el, val){
            if ($el.hasClass('min') || $el.hasClass('max')){
                $el.val(val.replace(/[.,]\d{1,2}$/, '').replace(/[^\d.,k]/g, ''));
            }
        };

        var $excats = $('#excats');
        // find category checkboxes that are unchecked, and pass them along in #excats
        var setExcats = function(){
            // count unchecked cats instead of checked cats so we can easily build excats
            var $uncheckedCats = $categoryInputs.not(':checked');
            var excatsVal = '';

            /*
               Cases for subcats checked or unchecked :
               *) no subcats to exclude - do nothing
               *) subcats exist and none excluded - do nothing
               *) more than one subcats excluded but not all - do nothing

               *) all subcats excluded  - search section

               *) all but one subcats excluded - just jump to that subcat
             */

            if ( $uncheckedCats.length === $categoryInputs.length - 1 && ! searchformAction.isFavorites() ) {
                // all subcategories but one are excluded, so search (and jump to) just that category
                searchformAction.category( $categoryInputs.filter(':checked').data('abb') );

            } else {
                var excatList = [];

                if ( $uncheckedCats.length === $categoryInputs.length && $categoryInputs.length > 0 && ! searchformAction.isFavorites() ) {
                    // there are subcategories and they are all excluded, search (and jump to) the section
                    searchformAction.category( window.sectionAbb );
                }

                $uncheckedCats.each(function(i, el){
                    var values = el.value.split(',');
                    excatList = excatList.concat(values);
                });

                excatsVal = diffSet({ values: excatList, isUncompressed: true }).asDiffString();

            }

            $excats.val(excatsVal);

        };

        $searchform.on('submit', function(e) {
            setExcats();

            $searchInputs.each(function(){
                var $el = $(this);
                var val = $el.val();

                // only submit inputs that have values
                includeIfNeeded($el, val !== '');
                sanitizeInput($el, val);
            });

            $searchform.attr('action', searchformAction);
        });
    }());

    // grow map vertically to top of footer
    var $map = $('#map');
    var growMap = function() {
        // map height should be from top of the map to top of the footer. extra 1px for Firefox for some reason
        var mapHeight = Math.round($('footer').offset().top - $map.offset().top - 1);
        $map.height(mapHeight);
        if (CL.maps.map) {
            CL.maps.map.invalidateSize();
        }
        if (CL.maps.map && ! $('.leaflet-control-zoom').length) {
            CL.maps.map.addControl(CL.maps.controls.fullsize);
        }
        CL.maps.thawMap();
    };

    // close popups, remove zoom controls, reset map to inline size
    var closeMapMode = function() {
        if (CL.maps.map) {
            CL.maps.map.closePopup(CL.maps.openPopup);
        }
        if ($('.leaflet-control-zoom').length) {
            CL.maps.map.removeControl(CL.maps.controls.fullsize);
        }
        $map.height(200);
        $map.removeClass('fullsize-map');
        CL.maps.freezeMap();
    };

    // changing anything in the search form causes the 'search' button to highlight
    var changes = {};
    var changecount = 0;
    var changedClass = 'changed_input';
    var changedAndClickme = changedClass + ' clickme';
    var $submitButton = $('.searchbtn');
    var $submitLink = $('.searchlink');
    var searchformChanged = false;
    var toggleModifiedState = function(isModified, key, $parent_el, $el, extra_fun ){
        /*
            isModified: [Boolean] whether to toggle on or off
            key: key name in changes object for this control
            $parent_el: jquery object to toggle changed class on
            $el: the jquery object that caused the change event.

            This function keeps track of the original state of the controls and
            toggles an indication that they have changed depending if they match
            their original state or not.
        */
        if (isModified !== Boolean(changes[key])) {
            $parent_el.toggleClass(changedClass, isModified);
            changes[key] = !changes[key];
            changecount += isModified ? 1 : -1;
            searchformChanged = Boolean(changecount);
            $submitButton.toggleClass(changedAndClickme, searchformChanged);
            $submitLink.toggleClass(changedAndClickme, searchformChanged);
            if (extra_fun) {
                extra_fun( key, $parent_el, $el );
            }
        }
    };

    var buildStateShower = function( item, use_id, startVals, extra_toggle_fun ) {
        /*
          This function registers and actuates the toggleModifiedState function for a control.
          When the control is changed, the search button and the control will be highlighted via a
              class.
          If the control is changed back before submit, it is unhighlighted. If all controls are set
              back to their original states, the search button is also unightlighted.

          params :
                item : a dom element to watch for changes

                use_id : track the element by id. If false, it tracks it by name

                startVals : optional hash of element key to initial values.

                extra_toggle_fun : optional function to run when the control is changed.
                          passed in is the element key ( id or name ) and the jquery element itself
         */
        var $this = $(item);
        var type = $this[0].type;
        var state_key = use_id ? $this.attr( 'id' ) : $this.attr( 'name' );
        var startVal;

        if ( typeof startVals === 'undefined' || typeof startVals[ state_key ] === 'undefined' ) {
            if (type === 'checkbox') {
                startVal = $this.prop('checked');
            } else if (type === 'radio') {
                startVal = use_id ? $('input[id=' + $this.attr( 'id' ) + ']:checked').val() : $('input[name=' + $this.attr( 'name' ) + ']:checked').val();
            } else {
                startVal = $this.val();
            }
            if (startVals) {
                startVals[ state_key ] = startVal;
            }
        } else {
            startVal = startVals[ state_key ];
        }

        $this.on('change keyup', (function($that, key, initVal, extra_fun) {
            if (type === 'checkbox') {
                return function() {
                    toggleModifiedState( $that.prop('checked') != initVal, key, $that.parent(), $that, extra_fun );
                };
            } else if (type === 'radio') {
                var $inputs = $('input[name=' + $that.attr('name') + ']');
                return function() {
                    toggleModifiedState( $inputs.filter(':checked').val() !== initVal, key, $inputs.parent(), $inputs, extra_fun );
                };
            } else {
                return function(e, $el) {
                    // if $el is passed in treat it as the visible input, otherwise use $that (good for highlighting other things in place of hidden elements)
                    toggleModifiedState( $that.val() !== initVal, key, $el || $that, $el || $that, extra_fun );
                };
            }
        })( $this, state_key, startVal, extra_toggle_fun ) );
    };

    // event callback for toggling search button call to action
    var triggerStateChange = function(input) {
        var $this = $(input);
        buildStateShower(
            input,
            $this.hasClass('multi_checkbox') || $this.hasClass('use-id'),
            undefined,
            $this.hasClass('multi_checkbox') ?
                function(key,$parent_el,$el) {
                    var $header = $( '#headerattr_' + $el.data('attr') );
                    var checkedCount = Number($header.data( 'checked-count' )) || 0;

                    if ($el.prop('checked')) {
                        checkedCount++;
                    } else {
                        checkedCount--;
                    }

                    $header.data( 'checked-count', checkedCount );
                    $header.removeClass( 'strong' );
                    if (checkedCount > 0) {
                        $header.addClass( 'strong' );
                    }
                }
                :
                undefined
        );
    };

    // watch all search inputs for changes and give feedback to the user that they are changed.
    $searchInputs.not('.selectallcb').not('.autosubmit').not('.no_changed_input').each( function(key, val) {
        triggerStateChange(val);
    });

    var addFloater = function() {
        var $floater = $('#floater');
        var $payload = $floater.find('img.payload');
        var visible = false;

        $('.result-image').on('mouseover', function(){
            var imgID = ($(this).data('idList') || [])[0];

            // don't show image preview popup if there's no image!
            if (imgID) {
                $floater.show();
                $payload.attr('src', CL.image.url(imgID, 'gallery'))
                    .on('load', function() {
                        $('#floater').addClass('f');
                    });
                visible = true;
            }
        })
        .on('mouseout', function(){
            $floater.hide().removeClass('f');
            // set src back to nothing so if user re-hovers same image 'load' event fires again
            $payload.attr('src', '');
            visible = false;
        })
        .on('mousemove', function(e) {
            if (visible){
                $('#floater').css({'left': e.pageX+15 + 'px', 'top': e.pageY+15 + 'px'});
            }
        });
    };

    var removeFloater = function() {
        $('.result-image').off();
        $('#floater').hide();
    };

    var galleryThumbTemplate = $('#gallerycarousel').html().trim();

    $body.on('click', '.result-row .arrow', function(e) {
        // make sure clicking a gallery arrow doesn't follow link to ad
        e.preventDefault();
    });

    var makeImg = function(id, size, classes) {
        classes = classes || '';
        return '<img alt="" class="' + classes + '" src="' + CL.image.url(id, size) + '">';
    };

    var initializedThumbs = {};
    var initializedGalleries = {};

    var processImages = function (size) {
        var $rows = $('.result-row');

        $rows.each(function(i, row){
            var $row = $(row);
            /*
            in eventy sections, a post can appear more than once if
            it spans multiple days. this ID allows each once to get
            proper image treatment, instead of just the first one
            */
            var uniquePost = i + '-' + $row.data('pid');
            // only find the result-image elements directly below the
            // row. Bundled duplicate rows are also below the row and
            // contain their own result images, which should not be clobbered by this
            var $el = $row.find('> .result-image');
            var ids = $el.data('idList');

            if ( ! Array.isArray( ids ) ) {
                // convert comma-separated string into real array and stash it
                ids = ( $el.data('ids') || '' );
                ids = ids ? ids.split(',') : [];
                $el.data('idList', ids);
            }

            if ( ids.length === 0 ) {
                // zero images, mark as empty
                $el.addClass('empty').attr('title', window.noImageText);
            } else {
                /* we load thumbnails lazy because some browsers will pull all the images
                * down even if the enclosing elements are hidden.  So, don't do that for
                * people on 14.4 modems browsing in list view */
                if ( size === 'thumb' && ! initializedThumbs[uniquePost] ) {
                    initializedThumbs[uniquePost] = true;
                    $el.prepend(makeImg(ids[0], 'thumb', 'thumb'));
                } else if ( size === 'gallery' && ! initializedGalleries[uniquePost] ) {
                    initializedGalleries[uniquePost] = true;

                    if ( ids.length === 1 ) {
                        $el.prepend(makeImg(ids[0], 'gallery'));
                    } else {
                        // more than one image and no carousel exists already, set up on-demand carousel
                        var divs = ids.map(function(imgID, i){
                            // first div should have image, the rest will be loaded lazily when swipe gallery is actuated
                            var guts = i === 0 ? makeImg(imgID, 'gallery') : '';
                            return '<div>' + guts + '</div>';
                        }).join('');

                        $el.append('<div class="swipe"><div class="swipe-wrap">' + divs + '</div></div>' + galleryThumbTemplate);

                        var initialized = false;

                        CL.swipe.makeGallery($el, {
                            callback: function() {
                                if (initialized) {
                                    return;
                                }

                                $el.find('.swipe-wrap div').each(function(i, el){
                                    // first image already inserted above
                                    if (i === 0) {
                                        return;
                                    }

                                    // the gallery has been actuated so load the rest of the images
                                    // if there are exactly two slides, Swipe duplicates them for a total of 4
                                    // slides so you can always swipe in either direction and have a slide
                                    // "waiting in the wings". in this case, it goes beyond the array of image
                                    // ids, so if ids[i] doesn't exist, subtracting the length should get you
                                    // to the correct image id
                                    $(el).html(makeImg(ids[i] || ids[i - ids.length], 'gallery'));
                                });

                                initialized = true;
                            }
                        });
                    }
                }
            }
        });
    };

    // getter/setter for cookie of type of view to show for search page
    var viewModes = {};
    var tocmodeCookie = function (val) {
        var cookieName = 'cl_tocmode';

        if (typeof val === 'undefined') { // getter
            var modes = CL.cookies.getItem(cookieName);

            if (modes){
                modes.split(',').forEach(function(tuple){
                    tuple = tuple.split(':');

                    // e.g. sss:grid splits to ['sss', 'grid']
                    viewModes[tuple[0]] = tuple[1];
                });
            }

            return viewModes[window.sectionBase] || window.defaultView;
        } else { // setter
            var date = new Date();
            // one year expiration
            date.setTime(date.getTime() + (365 * 24 * 60 * 60 * 1000));

            viewModes[window.sectionBase] = val;

            // final string looks like:  "sss:grid,hhh:map,bbb:list"
            var allCatModes = Object.keys(viewModes).map(function(cat){
                return cat + ':' + viewModes[cat];
            }).join(',');

            // clear any specific <host>.craigslist.org cookie
            CL.cookies.removeItem(cookieName, {path: '/'});
            CL.cookies.setItem(cookieName, allCatModes, { expires: date, path: '/', domain: CL.url.baseDomain });
        }
    };

    $('.backtotop').on('click', function(e){
        $(window).scrollTop(0);
        e.preventDefault();
    });

    // view mode logic
    CL.page.viewMode = tocmodeCookie();
    var oldMode;
    var viewMode = function(mode) {
        var modes = {
            list: function(){
                closeMapMode();
            },
            pic: function(){
                // only initialize for hover-capable devices
                if (! CL.browser.isTouchCapable) {
                    addFloater();
                }
                closeMapMode();
                processImages('thumb');
            },
            grid: function(){
                closeMapMode();
                removeFloater();
                processImages('gallery');
            },
            map: function(){
                CL.maps.init();
                $('#mapcontainer').css({height: '99%'});
                growMap();
                // default map to full screen mode on mobile
                if (CL.page.isMobile) {
                    CL.maps.controls.fullsize.fullscreen()
                }
                CL.maps.countMarkers();
            }
        };

        oldMode = CL.page.viewMode;
        CL.page.oldMode = oldMode;

        // 1 in 3844 chance user view mode will be logged
        if ( /^BB/.test( CL.cookies.getItem('cl_b') ) ) {
            $.ajax( '/stats', {
                type: 'HEAD',
                data: {
                    'type': 'search-view-mode',
                    'from': oldMode,
                    'to': mode
                }
            });
        }

        // if given an invalid mode,
        // or if the mode is not an option for the category/subcategory
        // (i.e. map mode is not an option in all personals subcats except for
        // missed connections),
        // default to list
        if ( ! modes[mode] || ! $('#' + mode + 'view').length ) {
            mode = 'list';
        }

        // set new mode class (for page styling)
        $body.removeClass(Object.keys(modes).join(' ')).addClass(mode);

        // record the new mode
        CL.page.viewMode = mode;

        // run the view-changing code
        modes[mode]();

        // set the cookie
        tocmodeCookie(mode);
    };


    $('.open-map-view-button').on('click', function() {
        viewMode('map');
        $('.dropdown').trigger('updateView');
    });

    $('.close-map-view-button').on('click', function(e) {
        if (CL.page.oldMode == 'map') {
            CL.page.oldMode = window.defaultView;
        }
        viewMode(CL.page.oldMode);
        $('.dropdown').trigger('updateView');
        e.stopPropagation();
    });

    // instantiate the view/sort dropdowns
    $('.search-view .dropdown').dropdown({
        // pass viewmode change handling as callback to dropdown handler
        onSelect: function (e) {
            e.preventDefault();

            var newMode = $(e.target).data('selection');

            // if hashChange is not supported, don't change the hash
            if (!CL.browser.hashChange) {
                return;
            }

            if (newMode !== CL.page.viewMode) {
                viewMode(newMode);
            }
        }
    });

    $('.search-sort .dropdown').dropdown();

    // see if hash was set before JS loaded and make sure a hash is set
    var noHashMode = ''; // what mode should we be in when there's no hash?
    var hashMode = (location.hash || '').replace('#', '');

    if ( hashMode ) {
        if ( hashMode === 'hidden' ) {
            viewMode(CL.page.viewMode);
            CL.banish.show();
        } else {
            viewMode(hashMode);
        }
    } else {
        // initialize the page view with the proper image mode
        noHashMode = CL.page.viewMode;
        viewMode(noHashMode);
    }

    // handles when user clicks back button, show previous view(s)
    if (CL.browser.hashChange) {
        $window.on('hashchange', function(){
            var newMode = (location.hash || '').replace('#', '');

            // toggle in and out of showing banished posts
            if ( newMode === 'hidden' ) {
                oldMode = CL.page.viewMode;
                CL.banish.show();
                return;
            } else if ( newMode !== 'hidden' && CL.page.showBanished ) {
                CL.banish.hide();
                newMode = newMode || CL.page.viewMode; // if a mode is given, use that, otherwise use whatever mode the page was in before
            }

            // may have started the page with no hash, so maybe switch to that mode
            if ( ! newMode && noHashMode ) {
                newMode = noHashMode;
            }

            // prevent double-processing when user clicks mode button
            if ( newMode !== CL.page.viewMode ) {
                viewMode(newMode);
            }
        });
    }

    var $ispaid = $('#is_paid');

    $('.remuneration').on('click', 'a', function(e){
        e.preventDefault();

        $ispaid.val($(this).data('val'));
        $searchform.submit();
    });

    $('.purveyor').on('click', 'a', function(e){
        e.preventDefault();

        searchformAction.purveyor($(this).data('val'));
        $searchform.submit();
    });

    // autosubmit title only if query terms
    $('input[name=srchType]').on('click', function(e){
        if ($query.val()) {
            $searchform.submit();
        }
    });

    // if the form has changed, re-submit along with a hidden input that
    // will tell the resulting page to continue on to saving or alerting the search
    var $savealertLinks = $('.savealert a');
    $savealertLinks.on('click', function(e){
        var self = this;
        var href = self.href;
        e.preventDefault();

        // CSRF protection for the above links. Fetch the token from the server and
        // append it to the link clicked. If the links lack the token (nojs or whatever)
        // the user will just get a confimation page first
        $.ajax('/session/?v=1', { dataType: 'json', timeout: 1500 }).done(function(token){
            window.location.href = href + encodeURIComponent('&_csrf=' + token.csrf);
            if ( searchformChanged ) {
                var action = $(self).data('action');
                $searchform
                    .append('<input type="hidden" name="' + action + '" value="1">')
                    .append('<input type="hidden" name="_csrf" value="' + token.csrf + '">')
                    .submit();
            }
        }).fail(function(){
            // probably timed out, just go to confirmation page
            window.location.href = href;
            if ( searchformChanged ) {
                var action = $(self).data('action');
                $searchform
                    .append('<input type="hidden" name="' + action + '" value="1">')
                    .submit();
            }
        });
    });

    // placeholders for browsers that don't support it LOOKIN AT YOU, IE 9--
    if ($.fn.DefaultValue && !CL.browser.placeholder) {
        $('input[placeholder]').each(function(i, el){
            var $this = $(el);
            $this.DefaultValue($this.attr('placeholder'));
        });
    }

    // click handler for the little green map links in listview
    // $('.maptag').click(function () {
    //     // do it this way to actually change window.location.hash, otherwise it's handler-only
    //     $('#mapview')[0].click();
    //     CL.maps.zoomToPosting($(this).data('pid'));
    // });

    // popular searches - populates search box and triggers search when clicked
    $('.experimentalFeature a').on('click', function(e) {
        var query = $(this).data('query');
        if (query) {
            e.preventDefault();
            $query.val(query);
            $searchform.submit();
        }
    });


    // general show/hide code
    (function(){
        // toggle show and hide other categories
        var $moreCats = $( '.morecats' );
        var $otherCats = $( '.othercats' );
        var $searchOptionsContainer = $('.search-options-container');
        var $showOptions = $('.search-options-header');
        var otherCatsVisible = ! $otherCats.hasClass('closed');
        var searchOptionsVisible = false;

        $moreCats.on('click', function() {
            otherCatsVisible = ! otherCatsVisible;
            $otherCats.add($moreCats).toggleClass('closed');
        });

        // toggle sliding search bar
        $('.form-tab').on('click', function(e) {
            var isHidden = $body.toggleClass('hide-search').hasClass('hide-search') ? 1 : 0;

            growMap();

            CL.cookies.setItem('hidesearch', isHidden, { path: '/', domain: CL.url.baseDomain });
        });

        // hide options in narrow view
        $showOptions.on('click', function() {
            searchOptionsVisible = ! searchOptionsVisible;
            $searchOptionsContainer.toggleClass('options-visible');
            $showOptions.toggleClass('options-visible');
        });

    }());

    /*
       The multi attribute checkboxes behavior is controlled here.
       There are three distinct actions:
       1. Show/hide the list by clicking on the title
       2. Select/deselect all checkboxes in the list
       3. For long (>6 items) lists, show more or fewer options based on what was selected when the page loaded
    */
    $('.search-attribute').each(function(i, el) {
        var $searchAttribute = $(el);
        var attr = $searchAttribute.data('attr');
        var $title = $searchAttribute.find('.title');
        var $list = $searchAttribute.find('.list');
        var $selectAll = $list.find('.selectall');
        var $moreLess = $list.find('.moreless');
        var $items = $list.find('.multi_checkbox');

        // show / hide the entire list when clicking the title
        $title.on('click', function() {
            $searchAttribute.toggleClass('hide-list');
        });

        // click handler for checkboxes
        $list.on('change', '.multi_checkbox', function(e){
            var count = $items.filter(':checked').length;
            var anyItemsSelected = count > 0;

            // with nothing selected, show "select all"
            // with one or more selected, show "deselect all"
            $selectAll.toggleClass('selected', anyItemsSelected);

            // title gets bold if anything in the list is checked
            $title.toggleClass('strong', anyItemsSelected);
        });

        // select all
        $selectAll.on('click', '.all', function(e){
            $items.prop( 'checked', true ).trigger('change');

            // when selecting all, make sure to show the full list so the user understands what "all" means
            $moreLess.find('.more').trigger('click');
        });

        // deselect all
        $selectAll.on('click', '.none', function(e){
            $items.prop( 'checked', false ).trigger('change');
        });

        // show more...
        $moreLess.on('click', '.more', function() {
            $list.removeClass('short-list');
        });

        // show fewer...
        $moreLess.on('click', '.less', function() {
            $list.addClass('short-list');
        });
    });

    // 'select / deselect all' options on category list
    var $selectAllCatChecks = $('.catcheck').not('.selectallcb');
    var $selectAllCB = $('.catcheck.selectallcb');
    $selectAllCatChecks.on('change', function(e){
        var $this = $(this);
        var excatList = diffSet({ values: $( '#breadcrumbform #excats' ).val() });

        // See if we need to check/uncheck the select all box
        if ($selectAllCatChecks.not(':checked').length) {
            $selectAllCB.prop( 'checked', false).trigger('change');
        } else {
            $selectAllCB.prop( 'checked', true).trigger('change');
        }

        if ( $this.prop('checked') ) {
            excatList.remove( $this.val().split( ',' ).map(Number) );
        } else {
            excatList.add( $this.val().split( ',' ).map(Number) );
        }

        $( '#searchform #excats,#breadcrumbform #excats' ).val( excatList.asDiffString() );
        $this
            .closest('.selectall').toggleClass('checked')
            .closest('.searchgroup').find('input[type=checkbox]').not($this)
                .prop('checked', $this.prop('checked'))
                .trigger('change'); // trigger change for 'changed input' highlighting
    });

    $selectAllCB.on('click', function(e) {
        var checkedValue = $(this).prop('checked');
        $selectAllCatChecks.each(function() {
            $(this)
                .prop('checked', checkedValue)
                .trigger('change');
        });
    });

    var refr, streamSearch;
    CL.when.localStorageAvailable.done(function(ls){
        try {
            // record this search results for the prev and next links
            streamSearch = CL.searchStream.fetch( document.location.href.replace( /^https?:../, '' ) );
            streamSearch.resultHeaderScan();
            streamSearch.save();
            refr = streamSearch.curSearch();
            // set so that the posting opens up with the guaranteed prev/next
            $body.on( 'click', '.hdrlnk', function() {
                    // when a posting is clicked, set the search in local storage that
                    // tells postings how to lookup the prev, next and back to search links
                    streamSearch.setSearch( refr );
            } );
        } catch( err ) { }
    });

    // AJAX results
    (function(){
        if (! CL.browser.pushState) {
            return;
        }

        var pageSize = 120;
        // grab url params so we can update first / prev / next links
        var params = CL.url.params();

        var $rows = $('.rows');
        var $paginator = $('.paginator');
        var total = Math.min( Number( $paginator.find('.totalcount').first().text() ), window.maxResults );
        var $first = $paginator.find('a.first');
        var $prev = $paginator.find('a.prev');
        var $next = $paginator.find('a.next');
        // start index of result set
        var currentIndex = Number(params.s) || 0;

        var nextFetchRequested = false;

        // if s=XXX value isn't a multiple of pageSize, shenanigans may be afoot so just bail
        if ( currentIndex !== 0 && currentIndex % pageSize > 0 ) {
            return;
        }

        // stores completed DOM results
        var $range = $('.paginator .range');
        var htmlResults = {};

        var fillContent = function(startRow){
            if (htmlResults[startRow]){
                // #moon is the end-of-results message
                htmlResults[currentIndex] = $rows.find('.result-row, #moon').detach(); // for some reason .replaceWith grinds chrome to a stop
                $rows.prepend( htmlResults[startRow] );
            } else {
                // we don't have the results requested, so bail
                return false;
            }

            // populate images
            viewMode(CL.page.viewMode);
            // init favorites stars
            CL.favorites.init();

            // set so that the posting opens up with the guaranteed prev/next
            $( '.hdrlnk' ).on( 'click', function() {
                    streamSearch.setSearch( refr );
            } );

            return true;
        };

        var fetchData = function(index){
            var url = createURL({ index: index, ajax: true });

            if ( ! htmlResults[index] && index >= 0 && index < total ) {
                $.get(url).done(function(data){
                    htmlResults[index] = $(data.trim()).find('.content .result-row');
                });
            }
        };

        var createURL = function(opts){
            opts = opts || {};

            if (opts.index) {
                params.s = opts.index;
            } else {
                delete params.s;
            }

            var path = window.location.pathname;

            var paramArray = Object.keys(params).sort().map(function(key){
                var val;
                if ( Array.isArray(params[key]) ) {
                    val = params[key].join('&' + key + '=');
                } else {
                    val = params[key];
                }
                return key + '=' + val;
            });

            var paramString = paramArray.join('&');

            if (paramString) {
                paramString = '?' + paramString;
            }

            return path + paramString;
        };

        var updateCounts = function(){
            var start = currentIndex + 1;
            var end = Math.min(currentIndex + pageSize, currentIndex + htmlResults[currentIndex].length);
            $range.text( start + ' - ' + end );
        };

        var updateLinks = function(){
            $prev.attr('href', createURL({ index: currentIndex - pageSize }));
            $next.attr('href', createURL({ index: currentIndex + pageSize }));
        };

        var paginateAction = function(button, e, moveBy){
            // if everything goes well, fill in results via ajax. otherwise, just let the link get followed
            if ( fillContent(currentIndex + moveBy) ) {
                e.preventDefault();

                // scroll the page to the top
                $window.scrollTop(0);

                currentIndex += moveBy;

                updateCounts();
                updateLinks();

                history.pushState({ index: currentIndex }, undefined, createURL({ index: currentIndex }));

                $paginator.toggleClass('firstpage', currentIndex === 0);
                $paginator.toggleClass('lastpage', (currentIndex + pageSize) >= total);

                // queue up next page of data if it's the previous page
                if (moveBy < 0) {
                    fetchData(currentIndex + moveBy);
                }

                // we're on a new page, so reset the "next page fetch" flag
                nextFetchRequested = false;
            }
        };

        // prefetch the previous page (we prefetch the next page conditionally on scrolling down the current page)
        fetchData(currentIndex - pageSize);

        $first.on('click', function(e){
            paginateAction(this, e, -currentIndex);
        });

        $prev.on('click', function(e){
            paginateAction(this, e, -pageSize);
        });

        $next.on('click', function(e){
            paginateAction(this, e, pageSize);
        });


        /**
         * TODO: prefetch disabled while gallery image loading bug persists, 05/01/2015
        var body = document.body;
        var html = document.documentElement;
        var scrollFun = $.debounce( 500, function() {
            if ( nextFetchRequested || viewMode === 'map' ) {
                return;
            }

            // fetch the next page once we've gotten halfway down the current page
            // we re-get window height every time because view or content might have changed,
            // both of which affect window height

            // thanks, IE8--. see: https://developer.mozilla.org/en-US/docs/Web/API/window.scrollY?redirectlocale=en-US&redirectslug=DOM/window.scrollY
            var scrollAmount = window.pageYOffset || html.scrollTop || body.scrollTop || 0;
            var docHeight = Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight );
            var windowHeight = window.innerHeight || html.clientHeight || body.clientHeight;

            if ( scrollAmount > ( docHeight - windowHeight ) / 2 ) {
                fetchData(currentIndex + pageSize);
                nextFetchRequested = true;
            }
        } );

        $window.on('scroll', scrollFun );
        */

        window.onpopstate = function(e){
            var newIndex = ( e.state && e.state.index ) || Number(CL.url.params().s) || 0;
            if ( fillContent(newIndex) ){
                updateCounts();
                currentIndex = newIndex;
            } else if ( newIndex !== currentIndex ) {
                /*
                sometimes (IOS, lookin' at you) window.onpopstate fires on
                initial page load instead of when it's actually supposed to.
                On false firings, event.state will be null. On real firings,
                an object with the index will be present. Either way, if the
                divined index and currentIndex are the same, no action is required
                */
                window.location.reload();
            }
            // in the case we don't have results and we are on the same page that popstate
            // requested, there's nothing to do, so do just that :-)
        };
    }());

    CL.autocomplete({
        type: 'search',
        buildParams: function( request ){
            return {
                term: request.term,
                cat: window.catAbb,
                area: window.areaID
            };
        },
        onSelect: function(e, ui){
            if ( ui.item.value ) {
                $query.val(ui.item.value);
                $searchform.submit();
            }
        }
    });

    CL.autocomplete({
        type: 'makemodel',
        buildParams: function( request ){
            // cat should be:
            // - blank if in a section (sss, sso, etc) so we can search all categories
            // OR
            // - the "all" version of a category that has owner/dealer/all (cta, even when searching ctd or cto)
            // OR
            // - the current category otherwise

            // start off with the current category
            var cat = window.catAbb;

            // make it the 'all' version if applicable
            if ( window.purveyorCategories ) {
                cat = window.purveyorCategories.all;
            }

            // if it's a section rather than a specific category, erase it
            if ( cat === window.sectionBase ) {
                cat = undefined;
            }

            var params = {
                term: request.term
            };

            if ( cat ) {
                params.cat = cat;
            }

            return params;
        },
        onSelect: function(e, ui){
            if ( ui.item.value ) {
                $('.auto_make_model').val(ui.item.value);
                $searchform.submit();
            }
        }
    });


    // the breadcrumbs have a number of selects that instantly change the page
    var $breadcrumbform = $('#breadcrumbform').on('submit', function(){
        $(this).attr('action', breadcrumbformAction);
    });

    // we have JS, so don't submit any SELECTs or empty INPUTs along with the form
    $breadcrumbform.find('select').removeAttr('name').end().find('input').each(function(){
        var $input = $(this);
        if ( $input.val() === '' ) {
            $input.removeAttr('name');
        }
    });

    $('.clear-all-banished').off('click').on('click',function(ev) {
        ev.preventDefault();
        CL.banish.clearAll();
        $( '.rows' ).empty();
        updateBanishedCounter();
    } );

    var breadcrumbformAction = new SearchURL($('#breadcrumbform').attr('action'));
    $('#areaAbb').on('change', function() {
        // if changing areas, then radius search and subarea needs to be actively cleared
        $breadcrumbform.find('input[name=postal]').remove();
        $breadcrumbform.find('input[name=search_distance]').remove();
        breadcrumbformAction.area($(this).val()).subArea('');
        $breadcrumbform.submit();
    });

    $('#subArea').on('change', function() {
        breadcrumbformAction.subArea($(this).val());
        $breadcrumbform.submit();
    });

    $('#catAbb, #subcatAbb').on('change', function() {
        breadcrumbformAction.category($(this).val()).isSearch(true);
        // if changing category, excats no longer applies
        $breadcrumbform.find('input[name=excats]').remove();
        // allow user to get out of favorites list
        $breadcrumbform.find('input[name=fl]').remove();
        $breadcrumbform.find('input[name=uf]').remove();
        $breadcrumbform.submit();
    });

    (function balance_widths( selector, extra ) {
        var max_width = 0;
        var $selector = $(selector);
        var max = Math.max;

        $selector.each(function(){
            var w = $( this ).width();
            max_width = max(max_width, w);
        });

        max_width += extra;

        $selector.css( 'min-width', max_width );
    }( '.event_attr_label', 7 ));

    // don't autosubmit inputs in narrow view; apply autosubmit inputs in larger viewports
    if (CL.browser.matchMedia) {
        var mediaQueryCheck = window.matchMedia('(max-width: 480px)');
        var mediaQueryTest = function(isNarrow) {
            if (isNarrow) {
                $( '.autosubmit' ).off('change').each( function(key, val) {
                    triggerStateChange(val);
                });
            } else {

                // html controls with autosubmit cause the search form to instantly submit
                // these typically include a checkbox ( search only titles ) or a select
                // ( like show number of bedrooms )
                $( '.autosubmit' ).off('change').on('change', function() {
                    $searchform.submit();
                });

                $('.options-visible').removeClass('options-visible');
            }
        };

        // initial media query test to set autosubmit listeners or not
        mediaQueryTest(mediaQueryCheck.matches);

        // listen for matchMedia events and handle viewport resizes accordingly
        mediaQueryCheck.addListener(function(mediaQueryList) {
            var isNarrow = mediaQueryList.matches;
            mediaQueryTest(isNarrow);
        });
    }

    // mobile-mode logic, relocated/reimplemented from cl.js
    (function() {
        $body.on('click', '.result-row', function() {
            if (CL.page.isMobile) {
                var href = $(this).find('.result-info a').attr('href');

                // if for some reason we couldn't find the href, don't use a busted link
                if (href){
                    window.location.href = href;
                }
            }
        });
    }());
    // check we are in an area which uses maps AND the cat is housing but not (swp,hsw,sha,gms) OR also enable if in garage sales
    if ( $body.hasClass('has-map') && ( (window.sectionBase === "hhh" && ! ["swp","hsw","sha"].includes(window.catAbb)) || (window.sectionBase === "sss" && window.catAbb ==="gms") ) ) {
        // enable map button if in desktop mode and on first page
        if (window.pagemode === "desktop" && ! CL.url.params().s) {
            $body.addClass('has-map-view-button');
        }
    }
}());
;
/*
 * NAME - reverseGeocodeUser
 *
 * SYNOPSIS
 *
 * get lat, lon from browser and run it through codegeo service
 *
 * DESCIPTION
 *
 * Call from any page you want the users general location.
 * Try to handle errors and DTRT. Controlled by callbacks.
 *
 * PARAMS
 *
 * extra:
 *     optional.  hash of extra key value pairs to send with the codegeo request.
 *     for example you could send {src: 'hp'} to indicate src was home-page.
 *
 * CALLBACKS
 *
 * onSuccess:
 *     mandatory. called with data returned from reverse geocoder.
 *     data format is list of hashes (see DATA FORMAT below).
 *
 * onError:
 *     optional.  called with string error message
 *
 * DATA FORMAT
 *
 * data comes back as list of hashes.  See URL below for live example.
 * postals are returned in order of increasing distance from input lat, lon
 *
 * [{
 *    "country":"US","subarea_id":"1","radius":"0.8","lat":"37.784","area_id":1,"region":"CA",
 *    "postal":"94105","hostname":"sfbay.craigslist.org","dist":"0.471","city":"San Francisco",
 *    "lon":"-122.393", ...
 * }]
 *
 * EXAMPLE
 *
 * $('button#locateMe').on('click', function(e) {
 *     e.preventDefault();
 *     e.stopPropagation();
 *     reverseGeocodeUser({
 *         onSuccess: function(loc) { console.log(loc) },
 *         onError: function(msg) { console.log(msg) }
 *     });
 * });
 *
 * NOTES
 *
 * This will only work in a secure (https) context.
 *
 * SEE ALSO
 *
 * https://post.craigslist.org/codegeo?lat=37.78&lon=-122.40
 * https://www.w3schools.com/html/html5_geolocation.asp
 * https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition
 *
 */
var reverseGeocodeUser = function(opts) {

    // sanity check
    if (!opts) return;
    if (!opts.onSuccess) return;

    // callbacks, extra params
    var onSuccess = opts.onSuccess;
    var onError   = opts.onError || function(msg) { return; };
    var params    = opts.extra || {}

    // see https://developer.mozilla.org/en-US/docs/Web/API/PositionOptions
    var geolocateOpts = {
        enableHighAccuracy: false,
        timeout: 10000,
        maximumAge: 30000,
    };

    // human readable message from getCurrentPosition
    var decodeError = function(error) {
        var msg = "";
        switch(error.code) {
            case error.PERMISSION_DENIED:
                msg = "Permission Denied."
                break;
            case error.POSITION_UNAVAILABLE:
                msg = "Location Unavailable."
                break;
            case error.TIMEOUT:
                msg = "Timeout."
                break;
            case error.UNKNOWN_ERROR:
            default:
                msg = "Unknown Error."
        }
        return msg + " " + error.message
    }

    try {
        if (CL.browser.geolocation) {
            navigator.geolocation.getCurrentPosition(function(loc) {
                    params.lat = loc.coords.latitude;
                    params.lon = loc.coords.longitude;
                    params.acc = loc.coords.accuracy;
                    $.ajax({
                        dataType: "json",
                        url: "/codegeo",
                        data: params,
                        success: function(data) { onSuccess(data) },
                        error: function(undefined, status, errMsg) { onError(status + " " + errMsg) }
                    });
                },
                function(error) { onError("Cannot get location. " + decodeError(error)) },
                geolocateOpts
            );
        } else {
            onError("Cannot get location.");
        }
    }
    catch (exception) {
        onError("Cannot get location. " + exception.message);
    }
};

/* {"sources":{"jquery.throttle-debounce-1.1.js":"5ab64c50feb82f8cdaf55121db590674","jquery.dropdown.js":"f715a009ab38a595b7207f7af3c31bae","searchmaps.js":"b42fb2794e9433e5e8bc0d6adfb17417","search.js":"09bc87868395e734cd23feff9f452fae","reverseGeocodeUser.js":"a76fdd58ec22fcd0f33c812c2fb72738","concat.json":"1cdbf501fb124e133de450a61914d16c"}} */